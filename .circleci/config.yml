version: 2.1
#################################################################
#           Executors
#################################################################
executors:
  docker: # Docker using the Base Convenience Image
    parameters:
      resource_class:
        type: string
        default: "small"
    docker:
      - image: 'cimg/base:current'
        auth:
          username: datagenx  # can specify string literal values
          password: $DOCKERHUB_PASSWORD  # or project environment variable reference      
    resource_class: <<parameters.resource_class>>
  
  windows:  # Windows using the default windows image
    parameters:
      resource_class:
        type: string
        default: "medium"
    machine:
      image: windows-default
      shell: 'powershell.exe -ExecutionPolicy Bypass'
    resource_class: <<parameters.resource_class>>


#################################################################
#           Commands
#################################################################
commands:
  cancel_workflow:
    parameters:
      workflow_id:
        type: string
    steps:
       - run:
          name: Cancelling the workflow
          command: |
            echo "curl -X POST "${CIRCLE_HOSTNAME%/}/api/v2/workflow/$CIRCLE_WORKFLOW_ID/cancel?circle-token=XXXXXXX"
            curl -X POST "${CIRCLE_HOSTNAME%/}/api/v2/workflow/$CIRCLE_WORKFLOW_ID/cancel?circle-token=$CIRCLE_TOKEN"          
    
  check_proxy_variables:
    steps:
      - run:
          name: check proxy env variables
          command: |
            echo "HTTP_PROXY --> ${HTTP_PROXY}" 
            echo "HTTPS_PROXY --> ${HTTPS_PROXY}" 
            echo "NO_PROXY --> ${NO_PROXY}" 
  # resource_class verification commands to execute depending on executor_type
  verify_resource_class:
    parameters:
      resource_class:
        type: string
        default: "small"
      executor_type:
        type: string
        default: "docker"
    steps:
      - when:
          condition:
            equal: [ "docker", << parameters.executor_type >> ]
          steps:
            - run:
                name: verify required Environment Variables
                command: |
                  if [ -z "${CIRCLE_HOSTNAME}" -o -z "${CIRCLE_TOKEN}" ];then
                    echo "You must provide 2 Environment Variables in project settings for this job to run."
                    echo "CIRCLE_HOSTNAME: Should be the scheme://domain of your install. \"https://ci.example.com\""
                    echo "CIRCLE_TOKEN: Should be the API Key of an admin or project level with Scope:All"
                    exit 1
                  fi
            - run:
                name: Verify that job ran with the requested resource_class option
                command: |
                  curl -k \
                  "${CIRCLE_HOSTNAME%/}/api/v1.1/project/github/$CIRCLE_PROJECT_USERNAME/$CIRCLE_PROJECT_REPONAME/$CIRCLE_BUILD_NUM?\
                  circle-token=$CIRCLE_TOKEN" | \
                  jq '.picard.resource_class.class' | grep <<parameters.resource_class>>
      - when:
          condition:
            equal: [ "windows", << parameters.executor_type >> ]
          steps:
            - run:
                name: verify required Environment Variables
                command: |
                  if (!((Test-Path env:CIRCLE_HOSTNAME) -and (Test-Path env:CIRCLE_TOKEN))) {
                    Write-Host "You must provide 2 Environment Variables in project settings for this job to run."
                    Write-Host "CIRCLE_HOSTNAME: Should be the scheme://domain of your install. "https://ci.example.com""
                    Write-Host "CIRCLE_TOKEN: Should be the API Key of an admin or project level with Scope:All"
                    Exit 1
                  }
            - run:
                name: Verify that job ran with the requested resource_class option
                command: |
                  $job = Invoke-RestMethod -URI "$env:CIRCLE_HOSTNAME/api/v2/project/gh/$env:CIRCLE_PROJECT_USERNAME/$env:CIRCLE_PROJECT_REPONAME/job/$env:CIRCLE_BUILD_NUM" `
                    -Headers @{ "Circle-Token" = "$env:CIRCLE_TOKEN" }
                  $job.executor.resource_class | Select-String -Pattern "<<parameters.resource_class>>"

remote_docker_defaults: &remote_docker_defaults
  docker:
    - image: 'cimg/base:2025.05-20.04'
      auth:  
        username: datagenx  # can specify string literal values
        password: $DOCKERHUB_PASSWORD  
  resource_class: "small"

basic_docker_build: &basic_docker_build
  name: "Build a really basic docker image"
  command: |
    dockerfile=Dockerfile
    echo "FROM alpine:latest" > $dockerfile
    echo "RUN echo hello" >> $dockerfile
    
    echo "Whoami"
    whoami
    echo "\nProcess List"
    ps -ef
    echo "\nDocker Image list"
    docker images ls
    echo "\nDocker Container list"
    docker ps -a
    echo "\nDocker Network list"
    docker network ls
    echo "\nDocker Bridge Network inspect"
    docker inspect $(docker network ls | grep -w bridge | awk '{print $1}')
    
    echo -n $DOCKERHUB_PASSWORD | docker login --username datagenx --password-stdin || echo "\n ***** Docker login failed ***** \n"
    docker build -f $dockerfile --tag throwaway:$CIRCLE_BUILD_NUM .
    docker run --rm throwaway:$CIRCLE_BUILD_NUM

contexts_defaults: &contexts_defaults
  docker:
    - image: 'alpine:latest'
      auth:  
        username: datagenx  # can specify string literal values
        password: $DOCKERHUB_PASSWORD  
  resource_class: "small"  
  working_directory: /a/contexts/test

workspaces_defaults: &workspaces_defaults
  docker:
    - image: 'cimg/node:current'
      auth:  
        username: datagenx  # can specify string literal values
        password: $DOCKERHUB_PASSWORD  
  resource_class: "small"
  working_directory: ~/foo/bar


#################################################################
#           Jobs
#################################################################
jobs:
  say-hello-docker:
    executor: docker
    steps:
      - checkout
      - run:
          name: "Say hello"
          command: "echo Hello, World!"
      - run:
          name: "Something About Me"
          command: "whoami; hostname;"

  check-branch-status:
    executor: docker
    steps:
      - checkout
      - run:
          name: "Install jq"
          command: |
            sudo apt-get update
            sudo apt-get install -y jq
      - run:
          name: "Get task token from socket"
          command: |
            TASK_TOKEN_SOCKET="/tmp/circleci-ts.sock"
            
            if [ ! -S "$TASK_TOKEN_SOCKET" ]; then
              echo "ERROR: Task token socket not found at $TASK_TOKEN_SOCKET"
              exit 1
            else
              lsof "$TASK_TOKEN_SOCKET"
            fi
            
            SOCKET_RESPONSE=$(echo "get_token" | nc -U "$TASK_TOKEN_SOCKET")
            
            if [ -z "$SOCKET_RESPONSE" ]; then
              SOCKET_RESPONSE=$(nc -U "$TASK_TOKEN_SOCKET")
              if [ -z "$SOCKET_RESPONSE" ]; then
                echo "ERROR: Failed to get response from socket"
                exit 1
              fi
            fi
            
            if ! echo "$SOCKET_RESPONSE" | jq empty 2>/dev/null; then
              echo "ERROR: Invalid JSON response from socket"
              echo "Response: $SOCKET_RESPONSE"
              exit 1
            fi
            
            TASK_TOKEN=$(echo "$SOCKET_RESPONSE" | jq -r '.token')
            
            if [ -z "$TASK_TOKEN" ] || [ "$TASK_TOKEN" = "null" ]; then
              echo "ERROR: No task token in socket response"
              exit 1
            fi
            
            echo "Task token obtained"
            echo "TASK_TOKEN=$TASK_TOKEN" >> $BASH_ENV
      - run:
          name: "Exchange task token for CircleCI token"
          command: |
            echo "Exchanging task token for CircleCI token..."
            CIRCLE_TOKEN_RESPONSE=$(curl -s -X POST \
              -H "Authorization: bearer $TASK_TOKEN" \
              "${CIRCLE_HOSTNAME%/}/api/v2/user/access-token")
            
            if ! echo "$CIRCLE_TOKEN_RESPONSE" | jq empty 2>/dev/null; then
              echo "ERROR: Failed to exchange task token for token"
              echo "Response: $CIRCLE_TOKEN_RESPONSE"
              exit 1
            fi
            
            CIRCLE_TOKEN_OBTAINED=$(echo "$CIRCLE_TOKEN_RESPONSE" | jq -r '.token')
            
            if [ -z "$CIRCLE_TOKEN_OBTAINED" ] || [ "$CIRCLE_TOKEN_OBTAINED" = "null" ]; then
              echo "ERROR: Invalid CircleCI token in response"
              exit 1
            fi
            
            echo "CircleCI token obtained"
            echo "CIRCLE_TOKEN_OBTAINED=$CIRCLE_TOKEN_OBTAINED" >> $BASH_ENV
      - run:
          name: "Get and check main branch pipeline"
          command: |
            echo "Getting main branch pipeline..."
            MAIN_BRANCH_RESP=$(curl -s -H "Circle-Token: $CIRCLE_TOKEN_OBTAINED" \
              "${CIRCLE_HOSTNAME%/}/api/v2/project/github/$CIRCLE_PROJECT_USERNAME/$CIRCLE_PROJECT_REPONAME/pipeline?branch=main")
            
            if ! echo "$MAIN_BRANCH_RESP" | jq empty 2>/dev/null; then
              echo "API error: $MAIN_BRANCH_RESP"
              exit 1
            fi
                      
            if ! echo "$MAIN_BRANCH_RESP" | jq -e '.items' > /dev/null 2>&1; then
              echo "ERROR: Invalid response format - no items array"
              exit 1
            fi
            
            ITEMS_COUNT=$(echo "$MAIN_BRANCH_RESP" | jq '.items | length' 2>/dev/null || echo "0")
            
            if [ "$ITEMS_COUNT" -eq 0 ]; then
              echo "[SUCCESS] No pipelines found for main branch - treating as clean state"
              exit 0
            fi
            
            LATEST_PIPELINE=$(echo "$MAIN_BRANCH_RESP" | jq -r '.items[0]')
            
            if [ "$LATEST_PIPELINE" = "null" ] || [ -z "$LATEST_PIPELINE" ]; then
              echo "ERROR: Latest pipeline is null or empty"
              exit 1
            fi
            
            PIPELINE_STATE=$(echo "$LATEST_PIPELINE" | jq -r '.state')
            PIPELINE_ID=$(echo "$LATEST_PIPELINE" | jq -r '.id')
            
            echo "Latest main pipeline: $PIPELINE_ID - State: $PIPELINE_STATE"
            
            if [ -z "$PIPELINE_STATE" ] || [ "$PIPELINE_STATE" = "null" ]; then
              echo "ERROR: Pipeline state is empty or null"
              exit 1
            fi
            
            if [ "$PIPELINE_STATE" = "success" ] || [ "$PIPELINE_STATE" = "created" ]; then
              echo "[SUCCESS] Latest main branch pipeline passed!"
              exit 0
            else
              echo "[FAILED] Latest main branch pipeline failed: $PIPELINE_STATE"
              exit 1
            fi
      - run:
          name: beat up APIs
          command: |
            function hitit {
              http_code=`curl -Ls -H "Circle-Token: $CIRCLE_TOKEN_OBTAINED" \
                -o response.txt -w "%{response_code}" \
                "$1"`
              if [ "$http_code" != "200" ]; then
                echo "API call to $1 failed with code $http_code"
                echo "$http_code $1" >> failures.txt
                cat response.txt
                echo -e "\n\n"
              else
                echo "Success $http_code to $1"
                echo "$http_code $1" >> successes.txt
              fi 
            }
            export project_slug="gh/${CIRCLE_PROJECT_USERNAME}/${CIRCLE_PROJECT_REPONAME}"

            hitit "https://ifconfig.me"
            hitit "${CIRCLE_HOSTNAME%/}/api/v2/project/${project_slug}"
            hitit "${CIRCLE_HOSTNAME%/}/api/v2/project/${project_slug}/checkout-key"
            hitit "${CIRCLE_HOSTNAME%/}/api/v2/project/${project_slug}/settings"
            hitit "${CIRCLE_HOSTNAME%/}/api/v2/me"
            hitit "${CIRCLE_HOSTNAME%/}/api/v1.1/project/${project_slug}"
            hitit "${CIRCLE_HOSTNAME%/}/api/v1.1/project/${project_slug}/tree/master"
            hitit "${CIRCLE_HOSTNAME%/}/api/v2/pipeline"
            hitit "${CIRCLE_HOSTNAME%/}/api/v2/project/${project_slug}/job/${CIRCLE_BUILD_NUM}"
            hitit "${CIRCLE_HOSTNAME%/}/api/v2/workflow/${CIRCLE_WORKFLOW_ID}"
            hitit "${CIRCLE_HOSTNAME%/}/api/v2/deploy/environments"
            hitit "${CIRCLE_HOSTNAME%/}/api/v2/projects/${CIRCLE_PROJECT_ID}/pipeline-definitions"
            hitit "${CIRCLE_HOSTNAME%/}/api/v2/project/${project_slug}/schedule"
            hitit "${CIRCLE_HOSTNAME%/}/api/v2/insights/${project_slug}/flaky-tests"
            echo "FAILED URLS"
            cat failures.txt

            echo "successful"
            cat successes.txt            


  env-subst-example:
    executor: docker
    environment:
      foo: bar
      alpha: beta
    steps:
      - checkout
      - run:
          command: echo 'the value of foo is "$foo" and next to alpha is "$alpha"' > template.tmpl
      - run:
          command: cat template.tmpl
      - run:
          command: circleci env subst < template.tmpl > output.txt
      - run:
          command: grep "bar" output.txt | grep "beta"

  # job definition for verifying the resource_class per each executor_type
  executor_resource_class:
    parameters:
      resource_class:
        type: string
        default: "small"
      executor_type:
        type: string
        default: "docker"
    executor:
      name: <<parameters.executor_type>>
      resource_class: <<parameters.resource_class>>
    steps:
      - verify_resource_class:
          resource_class: <<parameters.resource_class>>
          executor_type: <<parameters.executor_type>>

  check_if_environment_is_aws:
    executor: docker
    steps:
      - run:
          name: Verify AWS Environment
          command: |
            if [ -z "${CIRCLE_CLOUD_PROVIDER}" ];then
              echo "You must provide the CIRCLE_CLOUD_PROVIDER environment variable in project settings for this job to run.";
              exit 1;
            fi
            if [[ "${CIRCLE_CLOUD_PROVIDER}" != 'aws' ]]; then
              echo "This installation is not in an AWS environment. Cancelling downstream workflow.";
              echo "curl -X POST ${CIRCLE_HOSTNAME%/}/api/v2/workflow/$CIRCLE_WORKFLOW_ID/cancel?circle-token=XXXXXXX"
              curl -X POST "${CIRCLE_HOSTNAME%/}/api/v2/workflow/$CIRCLE_WORKFLOW_ID/cancel?circle-token=$CIRCLE_TOKEN"
            fi

  check_if_environment_is_gcp:
    executor: docker
    steps:
      - run:
          name: Verify GCP Environment
          command: |
            if [ -z "${CIRCLE_CLOUD_PROVIDER}" ];then
              echo "You must provide the CIRCLE_CLOUD_PROVIDER environment variable in project settings for this job to run.";
              exit 1;
            fi
            if [[ "${CIRCLE_CLOUD_PROVIDER}" != 'gcp' ]]; then
              echo "This installation is not in an GCP environment. Cancelling downstream workflow.";
              echo "curl -X POST ${CIRCLE_HOSTNAME%/}/api/v2/workflow/$CIRCLE_WORKFLOW_ID/cancel?circle-token=XXXXXXX"              
              curl -X POST "${CIRCLE_HOSTNAME%/}/api/v2/workflow/$CIRCLE_WORKFLOW_ID/cancel?circle-token=$CIRCLE_TOKEN"
            fi

  check_if_windows_is_enabled:
    executor: docker
    steps:
      - run:
          name: Verify if Windows enabled env flag is set to true
          command: |
            if [[ "${CIRCLE_WINDOWS_EXECUTOR}" != "true" ]]; then
              echo "Windows executor environment flag is not set to \"true\". Cancelling downstream workflow."
              # circleci-agent step halt  # this only halts the step, not the workflow
              curl -X POST "${CIRCLE_HOSTNAME%/}/api/v2/workflow/$CIRCLE_WORKFLOW_ID/cancel?circle-token=$CIRCLE_TOKEN"
            fi

  # vm jobs
  machine:
    machine: true
    resource_class: "small"
    steps:
      - check_proxy_variables    
      - run:
          <<: *basic_docker_build
      - run: |
          echo $SLEEP
          date
          sleep $SLEEP
          date
          echo 'Done sleeping.'
    environment:
      SLEEP: 1
  
  android_machine:
    machine:
      image: android-default
    resource_class: "small"      
    steps:
      - run:
          <<: *basic_docker_build
      - run: |
          echo $SLEEP
          date
          sleep $SLEEP
          date
          echo 'Done sleeping.'
    environment:
      SLEEP: 1

  aws_arm:
    machine:
      image: arm-default
    resource_class: arm.medium
    steps:
      - check_proxy_variables    
      - run:
          <<: *basic_docker_build
      - run: |
          echo $SLEEP
          date
          sleep $SLEEP
          date
          echo 'Done sleeping.'
    environment:
      SLEEP: 1

  remote_docker:
    <<: *remote_docker_defaults
    steps:
      - run: which docker
      - run: docker -v
      - check_proxy_variables      
      - setup_remote_docker
      - run:
          <<: *basic_docker_build
      - run: docker version

  docker_layer_caching:
    <<: *remote_docker_defaults
    steps:
      - run: which docker
      - run: docker -v
      - check_proxy_variables      
      - setup_remote_docker:
          docker_layer_caching: true
      - run:
          <<: *basic_docker_build
      - run: docker version

  machine_dlc:
    machine:
      docker_layer_caching: true
    resource_class: "small"      
    steps:
      - run: which docker
      - run: docker -v
      - check_proxy_variables
      - run:
          <<: *basic_docker_build
      - run: docker version

  # feature jobs
  contexts:
    <<: *contexts_defaults
    steps:
      - run: env | grep CONTEXT_END_TO_END_TEST_VAR
      - run: env

  multi-contexts:
    <<: *contexts_defaults
    steps:
      - run: env | grep MULTI_CONTEXT_END_TO_END_VAR
      - run: env

  write_workspace:
    <<: *workspaces_defaults
    steps:
      - run: mkdir stuff
      - run: echo 5 >./stuff/thing
      - persist_to_workspace:
          root: .
          paths:
            - stuff

  read_workspace:
    <<: *workspaces_defaults
    steps:
      - attach_workspace:
           at: ./attached
      - run: |
          if [[ $(< ./attached/stuff/thing) != '5' ]]; then
            echo 'Sadness, the value is not what we expected, so the workspace write/read did not work'
            exit 1
          else
            echo 'Yay, value matches'
            exit 0
          fi

  save_and_restore_cache:
    docker:
      - image: cimg/python:3.10
    resource_class: "small"      
    working_directory: ~/realitycheck
    steps:
      - checkout

      - run: mkdir -p stuff
      - run: echo 5 >./stuff/thing

      - save_cache:
          key: v3-file-cache-{{ .BuildNum }}
          paths:
            - ./stuff/thing

      - run: rm -rf ./stuff/thing
      - run: sleep 5

      - restore_cache:
            keys:
              - v3-file-cache-{{ .BuildNum }}

      - run: |
            if [[ $(< stuff/thing) != '5' ]]; then
              exit 1
            else
              echo "The cache was populated"
            fi

  artifacts_test_results:
    docker:
      - image: python:3.13.3
    resource_class: "small"      
    working_directory: ~/realitycheck
    steps:
      - checkout

      - run:
          name: Creating Dummy Artifacts
          command: |
            echo "my artifact file" > /tmp/artifact-1.txt;
            mkdir /tmp/artifacts;
            echo "my artifact files in a dir" > /tmp/artifacts/artifact-2.txt;

      - store_artifacts:
          path: /tmp/artifact-1.txt
          destination: artifact-file.txt

      - store_artifacts:
          path: /tmp/artifacts

      - store_test_results:
          path: test-results

  blobless-job:
    executor: docker  
    steps:
      - checkout:
          method: blobless
      - run:
          name: Print repo size
          command: du -sh .
      - run:
          name: Print .git/config
          command: cat .git/config

  full-job:
    executor: docker
    steps:
      - checkout:
          method: full
      - run:
          name: Print repo size
          command: du -sh .
      - run:
          name: Print .git/config
          command: cat .git/config



#################################################################
#           Workflows
#################################################################
workflows:
  docker_resource_class_jobs:
    jobs:
      - executor_resource_class:
          matrix:
            parameters:
              resource_class: [small, medium, medium+, large, xlarge]
              executor_type: [docker] # default, but re-defining for clarity

  windows_resource_class_jobs:
    jobs:
      - check_if_windows_is_enabled
      - executor_resource_class:
          matrix:
            parameters:
              resource_class: [windows.medium, windows.large, windows.xlarge]
              executor_type: [windows]
          requires:
            - check_if_windows_is_enabled

  vm_jobs:
    jobs:
      - machine
      - remote_docker
      - docker_layer_caching
      - machine_dlc
  
  aws_jobs:
    jobs:
      - check_if_environment_is_aws
      - aws_arm:
          requires:
            - check_if_environment_is_aws
  
  gcp_jobs:
    jobs:
      - check_if_environment_is_gcp
      - android_machine:
          requires:
            - check_if_environment_is_gcp

  feature_jobs:
    jobs:
      - save_and_restore_cache
      - contexts:
          context: org-global
      - multi-contexts:
          context: individual-local
      - write_workspace
      - read_workspace:
          requires:
            - write_workspace
      - artifacts_test_results

  other_jobs:
    jobs:   
      - env-subst-example
      - blobless-job
      - full-job

  main-pipeline-check-new:
      jobs:
        - check-branch-status
        - say-hello-docker:
            requires:
              - check-branch-status
